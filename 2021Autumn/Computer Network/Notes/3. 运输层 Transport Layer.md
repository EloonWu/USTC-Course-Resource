# 3.运输层 Transport Layer
## 3.1 概述和运输层服务
运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**功能。运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层协议将报文转换成运输层segement，然后由网络层将其封装成数据报，向目的地发送

### 3.1.1 运输层和网络层的关系
* 网络层提供了主机之间的逻辑通信；运输层为运行在不同主机上的进程之间提供了逻辑通信
* 运输层协议只工作在端系统中，将来自应用进程的报文移动到网络边缘，但对这些报文在网络核心如何移动并不做任何规定
* 运输协议能够提供的服务受制于底层网络层协议的服务模型
* 然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。

### 3.1.2 Internet 运输层概述
Internet为应用层提供了两种截然不同的运输层协议：一种是UDP：为调用它的应用程序提供了一种不可靠、无连接的服务；一种是TCP：它为调用它的应用程序提供了一种可靠的、面向连接的服务。

UDP和TCP的基本责任是将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程间的交付服务。将主机间的交付扩展到进程间的交付称为**运输层的多路复用和多路分解**

TCP提供可靠传输、同时还提供拥塞控制

## 3.2 多路复用与多路分解
运输层从网络层接收报文段，并将这些报文段中的数据交付给在主机上运行的适当的应用程序

将运输层数据报文段中的数据交付到正确的socket的工作称为**多路分解**；在源主机从不同socket中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为**多路复用**（**源端口字段**和**目的端口字段**、**周知端口号**）

### 3.2.1 无连接的多路复用与多路分解
为UDP socket分配端口号

假定在主机A中的一个进程具有UDP端口19157，它要发送一个应用程序数据块给位于主机B中的另一个进程，该进程具有UDP端口号46428。主句A中的运输层创建一个运输层报文段，其中包括数据、源端口号（19157）、目的端口号（46428）和两个其他值。然后，运输层将得到的报文段传递到网络层。网络层将该报文段封装到一个IP数据报中，并尽力而为的将报文段交付给接收主机。

一个UDP socket由一个二元组来标识，包含一个目的IP地址和一个目的端口号

### 3.2.2 面向连接的多路复用与多路分解
TCP socket由一个四元组来标识，包含源IP地址、源端口号、目的IP地址、目的端口号。当一个TCP报文段从网络到达一套台主机时，该主机使用全部四个值来讲报文段定向到相应的socket

服务器主机可以支持狠毒哦并行的TCP socket，每个socket与一个进程相联系，并由其四元组来标识每个socket

尽管会出现两个客户使用相同的目的端口号与同一个Web服务器通信的情况，但是服务器仍能分解这两个相同端口的连接，因为这两条连接有不同的IP地址

## 3.3 无连接运输：UDP
UDP从应用程序得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将**形成的报文段交给网络层**。网络层将该运输层报文段**封装到一个IP数据报中**，然后尽力而为的尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP**使用目的端口号**将报文段中的数据交付给正确的应用进程。值得注意的是：使用UDP时，在发送报文段之前，**发送方和接收方的运输层实体之间没有握手**。

在许多应用场合，UDP相较于TCP有以下优点：
* **关于何时、发送什么数据的应用层控制更为精细**     应用层将数据传输给UDP，UDP立即打包并传递给网络层；TCP有一个拥塞控制机制；
* **无需连接建立**     TCP在开始数据传输之前需要经过三次握手；UDP不需要任何准备即可进行数据传输
* **无连接状态**    TCP需要在端系统中维护连接状态；UDP不需要维护连接状态
* **分组首部开销小**     每个TCP报文段都有20字节的首部开销；UDP仅有8字节的首部开销

*使用UDP的应用时可以实现可靠数据传输的，这可通过在应用程序自身建立可靠性机制来完成*

### 3.3.1 UDP报文段结构
* 数据字段：应用层数据占据UDP报文段的数据字段
* UDP首部：4个字段，每个字段有两个字节组成
	* 源端口号
	* 目的端口号
	* 长度：指示了在UDP报文段中的字节数（首部+数据）
	* 检验和：接收方使用检验和来检查在该报文段中是否出现了差错

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-09-29 143443.png" style="zoom: 80%;" />

### 3.3.2 UDP检验和
发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被<a href="https://blog.csdn.net/qq_34902437/article/details/87938913">回卷</a>

在接收方，全部的16比特字（包括检验和）加在一起，如果该分组中没有差错，则在接收方该和应该为全1串；如果出现了0，则说明分组中出现了差错。



## 3.4 可靠数据传输原理

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-09-29 152714.png" style="zoom: 67%;" />

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-09-29 152832.png" style="zoom: 67%;" />

### 3.4.1 构造可靠数据传输协议
#### 3.4.1.1 经完全可靠信道的可靠数据传输 rdt1.0

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-09-29 153217.png" style="zoom:60%;" />

如图显示了rdt1.0发送方和接收方的有限状态机的定义，各自只有一个状态。

* rdt的发送端只通过rdt_send(data)事件接受来自较高层的数据，产生一个包含该数据的分组（经由make_pkt(data)动作），并将分组发送到信道中

* 在接收端，rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，从分组中取出数据（经由extract(packet, data)动作），并将数据上传给较高层（通过deliver_data(data)动作）

由于有了完全可靠的信道，不必担心出现差错，接收端就不必提供任何反馈信息给发送方

#### 3.4.1.2 经具有比特差错信道的可靠数据传输 rdt2.0

**自动重传请求协议（ARQ）**使用肯定确认和否定确认来使发送方知道哪些内容被正确接收，哪些内容接收有误需要重复。AQR协议中还需要另外三种协议功能来处理存在比特差错的情况：

* 差错检测
* 接收方反馈
* 重传

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-05-18 155042.png" style="zoom: 80%;" />

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-09-29 221729.png" style="zoom:80%;" />

如图表示了rdt2.0的有限状态机，该数据传输协议采用了**差错检测**、**肯定确认（ACK）**与**否定确认（NAK）**

* rdt2.0的发送端有两个状态，在左边的状态中，发送端正等待来自上层传输下来的数据，当出现rdt_send(data)事件时，发送方将产生一个包含待发送数据的分组，经由udt_send(sndpkt)操作发送该分组。右边状态中，如果发送方接收到一个ACK，则返回等待上层数据传输的状态；如果接收到一个NAK，则重传最后一个分组，并等待接收方的响应。**值得注意的是，在发送方等待接收方回应时，发送方无法发送分组，因此rdt2.0被称为停等（stop-and-wait）协议**
* rdt2.0的接收方只有一个状态。要么回答一个ACK，要么回答一个NAK



<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-01 143018.png" style="zoom: 80%;" />

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-01 143134.png" style="zoom:80%;" />

如图表示了rdt2.1的有限状态机，为解决ACK以及NAK分组受损的问题，在数据分组中添加一段新字段，让发送方对其数据分组编号。接收方只需要检查序号即可确定收到的分组是否是一次重传。

* rdt2.1的发送方发送分组后进入等待回复的状态，若收到ACK则跳转到下一个状态；若收到NAK则停留在原状态，进行一次重传
* rdt2.1的接收方的状态转移有三种情况：收到的分组未受损且不是重传（收到分组的序号等于等待的序号）则跳转到下一个状态，并回复ACK；收到的分组受损，则停留在原状态，并回复NAK；收到的分组未受损且是重传（收到分组的序号不等于等待的序号）则停留在原状态，并回复ACK，等待发送方发送下一个分组。

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-01 150238.png" style="zoom:80%;" />

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-01 230617.png" style="zoom:80%;" />



#### 3.4.1.3 经具有比特差错的丢包信道的可靠数据传输 rdt3.0

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 091451.png" style="zoom:80%;" />

发送方负责检验和恢复对包工作，发送方即选择一个时间值，已判定是否发生丢包，达到预设的时间值而未收到接收方的响应，则重传该分组。总结来讲，发送方所做的就是：1.每次发送一个分组时，便启动一个定时器；2.响应定时器中断；3.终止定时器

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 091606.png" style="zoom:80%;" />

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 091634.png" style="zoom:80%;" />

因为分组序号在0和1之间交替，因此rdt3.0有时被称为**比特交替协议**

### 3.4.2 流水线可靠数据传输协议

定义发送方（或信道）的利用率为：发送方实际忙于将发送比特送进信道所用的时间与发送时间之比。**而停等操作的利用率很低。**

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 092549.png" style="zoom:80%;" />

解决利用率低问题的方法是使用**流水线**：允许发送方发送多个分组而无需等待确认。流水线技术对可靠数据传输协议可带来如下的影响
* 必须增加序号范围，因为每个输送中的分组（不计入重传的）必须有一个唯一的序号，而且也许有多个在传输中未确认的报文
* 协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓冲那些已经发送但是没有确认的分组。
* 解决流水线的差错恢复有两种基本方法：**回退N步**和**选择重传**

### 3.4.3 回退N步 GBN

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 093911.png" style="zoom:80%;" />

上图显示了发送方看到的GBN协议的序号范围。将base定义为最早的未确认分组的序号，将nextseqnum定义为最小的未使用序号，将序号的范围分割为4段

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 094215.png" style="zoom:80%;" />

GBN发送方必须响应三种类型的事件：
* **上层的调用**：当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未确认的分组。如果窗口未满，则产生一个分组将其发送，并变更相应变量。如果窗口已满，在实际实现中，发送方会缓存这些数据，或者使用同步机制允许上层在仅当窗口不满时才调用rdt_send()
* **收到一个ACK**：在GBN协议中，对序号为n的分组的确认采取**累积确认**的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组
* **超时事件**：如果出现超时，发送方重传所有已经发送但未确认的分组。上图中的发送方仅使用一个定时器，它可被当做最早的已发送但未被确认的分组所使用的定时器。如果接收到一个ACK，但仍有已发送但未被确认的分组，则定时器被重新启动；如果没有已发送但未被确认的分组，该定时器被终止。

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 100746.png" style="zoom:80%;" />

GBN的接收方：如果序号为n的分组被正常接收，且按序，则接收方为分组n发送一个ACK，并将该分组的数据部交付给上层；在所有其他情况，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。**接收方不需要缓存任何失序分组**

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-02 101025.png" style="zoom:80%;" />


### 3.4.4 选择重传（SR）
选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传

SR发送方的事件与动作：

* **从上层收到数据**	当从上层收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在GBN中一样，要么将数据缓存，要么将其返回给上层一遍以后传输
* **超时**	定时器再次将用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组
* **收到ACK**	如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组

SR接收方的事件与动作

* **序号在[rcv_base, rcv_base+N-1]内的分组被正确接收**	在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没接收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动的分组的编号向上交付这些分组。
* **序号在[rcv_base-N, rcv_base-1]内的分组被正确收到**	在此情况下，必须产生一个ACK，即使该分组是接收方以前已确认过的分组
* **其他情况**	忽略该分组

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 165327.png" style="zoom:60%;" />

对于SR协议而言，窗口长度必须小于或等于序号空间大小的一半

## 3.5 面向连接的运输：TCP
### 3.5.1 TCP连接

* 点对点	TCP是在单个发送方与单个接收方之间的连接
* 可靠，有序比特流
* 流水线
* 全双工服务	如果进程A和进程B之间存在一条TCP连接，那么应用层数据既可以从A流向B，也可以从B流向A
	TCP从**发送缓存**中取出并放入报文段中的数据数量受限于**最大报文段长度MSS**，MSS通常根据最初确定的由本地主机发送的最大链路层帧长度（最大传输单元）设置
* 面向连接	在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即他们必须相互发送某些预备报文段，以建立确保数据传输的参数：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，客户再用第三个特殊的报文段作为响应。前两个报文段不承载有效载荷，而第三个报文段可以承载有效载荷
* 流控制

### 3.5.2 TCP报文段结构

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 185436.png" style="zoom:60%;" />

* 源端口号和目的端口号	用于多路复用/分解来自或送到上层应用的数据
* 检验和字段
* 序号字段和确认号字段	32bit+32bit 用于发送方和接收方实现可靠数据传输服务
* 接收窗口字段	16bit 用于流量控制
* 首部长度字段	4bit 指示了以32bit的字为单位的TCP首部长度
* 选项字段	可变长度
* 标志字段	6bit ACK用于指示确认字段中的值是有效的。RST、SYN、FIN用于连接建立和拆除

#### 3.5.2.1 序号和确认号
序号：TCP将数据视为无结构、有序的字节流，且序号是建立在传输的字节流上，而不是建立在传输的报文段的序列上。一个报文段的序号因此是该报文段首字节的字节流编号。如下图所示，给第一个报文段分配的序号是0，第二个报文段的序号是1000。

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 190127.png" style="zoom:60%;" />

确认号：主机A填充进报文段的确认号是主机A希望主机B收到的下一个字节的序号

#### 3.5.2.2 Telnet 一个案例
假设客户和服务器的起始序号分别是42和79，在TCP连接建立后但没有发送任何数据之前，客户等待字节79，服务器等待字节42。

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 191013.png" style="zoom:60%;" />

### 3.5.3 往返时间的估计与超时
TCP再用超时/重传机制来处理报文段的丢失问题。

#### 3.5.3.1 估计往返时间
SampleRTT表示从某报文段被发出到对该报文段确认被收到之间的时间量。TCP会维持一个SampleRTT的均值（称为EstimatedRTT）。一旦获得一个新SampleRTT值，TCP就会根据以下公式更新EstimatedRTT（指数滑动平均）
$$ EstimatedRTT=(1-\alpha) EstimatedRTT+\alpha SampleRTT$$        $$\alpha = 1/8 $$

定义RTT的偏差为DevRTT
$$ DevRTT = (1-\beta )·DevRTT + \beta· |SampleRTT- EstimatedRTT|$$    $$\beta =0.25$$

#### 3.5.3.2 设置和管理重传超时间隔
$$ TimeoutInterval = EstimatedRTT + 4·DevRTT $$

### 3.5.4 可靠数据传输
对于TCP发送方有三个与发送和重传有关的主要事件

* 从上层应用程序接收数据	TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。当报文段传给IP时，TCP就启动计时器
* 超时	TCP通过重传引起超时的报文段来响应超时事件。然后TCP重启计时器
* 收到ACK	TCP将ACK的值与SendBase比较（SendBase是最早未被确认的字节的序号）。

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 193407.png" style="zoom: 80%;" />

#### 3.5.4.1 一些例子

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 193804.png" style="zoom:60%;" />

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-09 191013.png" style="zoom:60%;" />


#### 3.5.4.2 超时间隔加倍
TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设置为先前的两倍。

#### 3.5.4.3 快速重传
冗余ACK就是再次确认某个报文段的ACK，而发送方先前已收到对该报文段的确认。

### 3.5.5 流量控制

一条TCP连接每一侧主机都为该连接设置了**接收缓存**。TCP为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。

TCP通过让发送方维护一个称为**接收窗口（rwnd）**的变量来提供流量控制，接收窗口相当于给发送方一个指示—该接收方还有多少可用的缓存空间。

假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为该连接分配了一个接受缓存，并用**RcvBuffer**来表示其大小，并且定义一下变量：

* LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号
* LastByteRcvd：从网络中到达的并且已放入主机B接受缓存中的数据流的最后一个字节的编号

由于TCP不允许已分配的缓存溢出，下式必须成立$LastByteRcvd-LastByteRead \leq RcvBuffer$
$rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]$

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 202528.png" style="zoom:60%;" />

主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方接收。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 203340.png" style="zoom:60%;" />

### 3.5.6 TCP连接管理

客户应用进程首先通知客户TCP，它想建立一个与服务器上某个进程之间的连接。客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接

* TCP连接的建立
	* 第一步	
	  * 客户TCP向服务器TCP发送一个特殊的TCP报文段（**SYN报文段**）。
	    * **SYN被置为1。**
	    * 客户会随机选择一个**初始序号**（client_isn），并将此编号置于序号字段中。该报文段会被封装在一个IP数据报中，发送给服务器。
	    * 不包含应用层数据
	* 第二步    
	  * 服务器接收到SYN报文段后，会为该TCP连接**分配缓存和变量**
	  * 向客户TCP发送**允许连接**的报文段（**SYNACK报文段**）。该报文段也不包含应
	    * **SYN位被置为1**，
	    * **确认号字段被置为client_isn+1**，
	    * 最后服务器选择自己的**初始序号**（sever_isn），并将其置于TCP报文段的序号字段中
	    * 不包含应用层数据
	* 第三步    
	  * 在收到SYNACK报文段后，客户也要给该连接**分配缓存和变量**。
	  * 客户向服务器发送报文段表示对SYNACK报文段的确认
	    * **SYN位置为0**，表示连接已经建立
	    * **确认号字段为sever_isn+1**
	    * 可以负载客户到服务器的数据

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 210108.png" style="zoom: 80%;" />


* TCP连接的关闭


  * 客户TCP向服务器发送一个首部FIN被置为1的报文段。当服务器接收到该报文段后就会回送一个确认报文段
  * 然后，服务器发送自己的终止报文段，其FIN被置为1，最后客户对这个服务器的终止报文段进行确认。

  <img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 210139.png" style="zoom: 80%;" />

  <img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 205936.png" style="zoom:60%;" />

  <img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 210001.png" style="zoom:60%;" />

当一台主机接收到一个TCP报文段，其端口号或源IP地址与该主机上进行的socket都不匹配时，该主机向源发送一个特殊重置报文段，该TCP报文段将RST位置为1。



## 3.6 拥塞控制

### 3.6.1 拥塞原因与代价

* 情况1：两个发送方和一台具有无穷大缓存的路由器

![](F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 211521.png)

* 情况2：两个发送方和一台均有有限缓存的路由器

![](F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 211904.png)

* 情况3：4个发送方和具有有限缓存的多台路由器及多跳路径

![](F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 212507.png)

代价：

1. 分组的到达速率接近链路容量时，分组将经历巨大的排队时延
2.  发送方必须执行重传以步长因为缓存溢出而丢失的分组
3.  发送方在遇到大时延所进行的不必要的重传会引起路由器利用其链路宽带来转发不必要的分组副本
4.  当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了

### 3.6.2 拥塞控制方法

根据网络层是否为运输层运输层拥塞控制提供了显式帮助来区分拥塞控制方法

* 端到端拥塞控制	网络层没有为运输层拥塞控制提供显式支持。TCP必须通过端到端的方法解决拥塞控制。
* 网络辅助的拥塞控制    
  * 采用阻塞分组（choke packet）的形式
  * 路由器标记从发送方流向接收方的分组中的某个字段来指示拥塞的产生，接收方一旦收到该分组，就会向发送方通知该网络拥塞指示



## 3.7 TCP拥塞控制

TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接方式流量的速率。如果发送方感知没有什么拥塞，就增加发送速率；如果感知到拥塞，就降低发送速率。

### 3.7.1 TCP发送方如何限制向连接发送流量的速率？

TCP发送方除了维护LastByteSent、LastByteAcked、rwnd几个变量以外，还维护了**拥塞窗口（cwnd）**，cwnd满足$LastByteSent-LastByteAcked \leq |cwnd,rwnd|$

发送方的方式速率大概是$\frac{cwnd}{RTT}bytes/s$.通过调节cwnd的值就可以调节发送速率。

### 3.7.2 TCP发送方如何感知拥塞的出现？

将TCP发送方的“丢包事件”定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。

当出现过度拥塞时，在沿着这条路径上的一台（或多台）路由器的缓存会溢出，引起一个数据报被丢弃。丢弃的数据报接着会引起发送方的丢包事件，发送方就会认为路径上出现了拥塞

### 3.7.3 TCP发送方采用何种算法改变其发送速率？

1. 慢启动

   当一条TCP连接开始时，cwnd的值通常初始置为一个MSS的较小值，使得初始发送速率大约为$MSS/RTT$。在慢启动状态，cwnd以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。**因此，TCP发送速率起始慢，但在慢启动阶段以指数增长。**

   * 如果存在拥塞，TCP发送方将cwnd设置为1并且重新开始慢启动过程。同时将ssthresh（慢启动阈值）设置为$cwnd/2$
   * 当cwnd的值等于ssthresh时，结束慢启动并且TCP转移到拥塞避免模式
   * 如果检测到三个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态

2. 拥塞避免

   当cwnd的值等于ssthresh时，每个RTT只将cwnd的值增加一个MSS

   * 当超时指示的丢包事件出现时，$ssthresh=cwnd/2$，$cwnd=1$，
   * 当收到3个冗余ACK的丢包事件出现时，$ssthresh=cwnd/2$，$cwnd=cwnd/2+3MSS$

3. 快速恢复

![](F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 222035.png)

![](F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 223120.png)

AIMD：加性增，乘性减

### 3.7.4 对TCP吞吐量的宏观描述

假设：忽略在超时事件后出现的慢启动阶段。设窗口的大小为W byte

$一条连接的平均吞吐量=\frac{0.75 \times W}{RTT}$

设丢包率为L，最大报文长度为MSS

$一条连接的平均吞吐量=\frac{1.22 \times MSS}{RTT \sqrt{L}}$



## 3.8 TCP公平性

![](F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 224705.png)

<img src="F:\Study_Sources\2021autumn\计算机网络\images\屏幕截图 2021-10-15 224955.png" style="zoom:80%;" />

1. 多媒体应用因为不希望传输速率收到限制，因而不在TCP上运行，而是选择UDP。当运行在UDP上时，这些应用能够以恒定的速率将其音频和视频数据注入网络并且偶尔出现丢包
2. 应用使用并行TCP连接可能会破坏公平
